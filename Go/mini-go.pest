// Rough representation of the grammar

// TODO : Update grammar


// Program

File         = { SOI ~ Program ~ EOI }

Program      = { TopLevelDecl* }

TopLevelDecl = { VarDecl ~ ";" | FunctionDecl }


// Expression

Expression  = { UnaryExpr ~ (BinaryOp ~ UnaryExpr)* }

UnaryExpr   = { UnaryOp* ~ PrimaryExpr }
PrimaryExpr = { Operand ~ ( Index | Arguments )* }

Operand     = { Literal | OperandName | "(" ~ Expression ~ ")" }
OperandName = { Identifier }

Index       = { "[" ~ Expression ~ "]" }
Arguments   = { "(" ~ ( Expression ~ ( "," ~ Expression )* ~ ","? )? ~ ")" }


// Operators

BinaryOp = { "||" | "&&" | AddOp | MulOp | RelOp }
RelOp    = { "==" | "!=" |"<=" | "<" | ">=" | ">" }
AddOp    = { "+" | "-" | "|" | "^" }
MulOp    = { "*" | "/" | "%" | "<<" | ">>" | "&^" | "&" }

UnaryOp  = { "+" | "-" | "!" | "^" }

AssignOp = { ( AddOp | MulOp )? ~ "=" }


// Type

Type = { "int" | "bool" | "string" | ArrayType | FunctionType | "(" ~ Type ~ ")" }


// Function declaration (definition)

FunctionDecl    = { "func" ~ FunctionName ~ Signature ~ FunctionBody }
FunctionName    = { Identifier }
FunctionBody    = { Block }

FunctionType    = { "func" ~ Signature }
Signature       = { NamedParameters ~ Result? }
Result          = { Type }
NamedParameters = { "(" ~ ( (NamedParameter ~ ( "," ~ NamedParameter )*) ~ ","? )? ~ ")" }
NamedParameter  = { Identifier ~ Type }
Parameters      = { "(" ~ ( (Type ~ ( "," ~ Type )*) ~ ","? )? ~ ")" }


// Statements

Statement      = { ReturnStmt | BreakStmt | ContinueStmt | ForStmt | VarDecl | IfElseStmt | Block | SimpleStmt }

ReturnStmt     = { "return" ~ Expression? }
BreakStmt      = { "break" }
ContinueStmt   = { "continue" }

ForStmt        = { "for" ~ ( ForClause | Condition )? ~ Block }
ForClause      = { SimpleStmt? ~ ";" ~ Condition? ~ ";" ~ SimpleStmt? }
Condition      = { Expression }

VarDecl        = { "var" ~ ( VarSpec | "(" ~ ( VarSpec ~ ";" )* ~ ")" ) }
VarSpec        = { Identifier ~ ( Type ~ ( "=" ~ Expression )? | "=" ~ Expression ) }

IfElseStmt     = { "if" ~ ( SimpleStmt ~ ";" )? ~ Expression ~ Block ~ ("else" ~ ( IfElseStmt | Block ))? }

Block          = { "{" ~ ( Statement? ~ ";")* ~ "}" }

SimpleStmt     = { Assignment | IncDecStmt | ShortVarDecl | ExpressionStmt }

Assignment     = { Expression ~ AssignOp ~ Expression }
IncDecStmt     = { Expression ~ ( "++" | "--" ) }
ShortVarDecl   = { Identifier ~ ":=" ~ Expression }
ExpressionStmt = { Expression }


// Array

ArrayType = { "[" ~ Expression ~ "]" ~ Type }


// Literal

Literal = {  IntLit | BoolLit | StringLit | ArrayLit | FunctionLit }


// Complex literals

FunctionLit       = { "func" ~ Signature ~ FunctionBody }

ArrayLit          = { ArrayLiteralType ~ ArrayLiteralValue }
ArrayLiteralType  = { ArrayType }
ArrayLiteralValue = { "{" ~ ( KeyedElementList ~ ","? )? ~ "}" }
KeyedElementList  = { KeyedElement ~ ( "," ~ KeyedElement )* }
KeyedElement      = { ( Key ~ ":" )? ~ Element }
Key               = { Expression }
Element           = { Expression | ArrayLiteralValue }


// Basic literals

IntLit      = @{ BinaryLit | OctalLit | HexLit | DecimalLit }
DecimalLit  = { "0" | '1'..'9' ~ ( "_"? ~ DecimalDigit )* }
BinaryLit   = { "0" ~ ( "b" | "B" ) ~ ( "_"? ~ BinaryDigit )+ }
OctalLit    = { "0" ~ ( "o" | "O" )? ~ ( "_"? ~ OctalDigit )+ }
HexLit      = { "0" ~ ( "x" | "X" ) ~ ( "_"? ~ HexDigit )+ }

BoolLit     = @{ "true" | "false" }

StringLit   = @{ "\"" ~ StringChar* ~ "\"" }
StringChar  = { !(Newline | "\\" | "\"") ~ UnicodeChar | EscapedChar }
EscapedChar = { "\\" ~ ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "\"" ) }


// Identifier

Identifier            = @{ !(Keyword | PredeclaredIdentifier) ~ Letter ~ ( Letter | UnicodeDigit )* }

Letter                = { UnicodeLetter | "_" }

Keyword               = { "break" | "func" | "if" | "else" | "continue" | "for" | "return" | "var" }

PredeclaredIdentifier = { "bool" | "int" | "string" | "true" | "false" | "nil" }


// Basic elements

DecimalDigit  = { '0'..'9' }
BinaryDigit   = { "0" | "1" }
OctalDigit    = { '0'..'7' }
HexDigit      = { '0'..'9' | 'A'..'F' | 'a'..'f' }

Newline       = { "\n" }
UnicodeChar   = { ANY }
UnicodeLetter = { LETTER }
UnicodeDigit  = { LETTER_NUMBER }


// Ignored symbols

WHITESPACE = _{ WHITE_SPACE }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
